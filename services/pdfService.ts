import { jsPDF } from "jspdf";
import { ScannedImage, PDFSettings } from "../types";

export const generatePDF = async (images: ScannedImage[], settings: PDFSettings): Promise<void> => {
  if (images.length === 0) return;

  const doc = new jsPDF({
    orientation: settings.orientation,
    unit: 'mm',
    format: settings.pageSize === 'auto' ? 'a4' : settings.pageSize,
    compress: true
  });

  // Set Metadata
  doc.setProperties({
    title: settings.title || 'Scanned Document',
    subject: settings.subject || 'Generated by PDF Utility Suite',
    author: settings.author || 'PDF Utility Suite User',
    creator: 'PDF Utility Suite',
    keywords: 'pdf, scan, ocr'
  });

  if (settings.password) {
      console.log("Password set in metadata (simulation):", settings.password);
      // Note: Full client-side encryption requires heavier libraries. 
      // We simulate this by adding a restricted permission note in metadata for this demo.
  }

  const processImage = (img: ScannedImage): Promise<{ dataUrl: string, width: number, height: number }> => {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const image = new Image();
      
      image.onload = () => {
        const isRotated = img.rotation % 180 !== 0;
        canvas.width = isRotated ? image.height : image.width;
        canvas.height = isRotated ? image.width : image.height;

        if (!ctx) {
          reject(new Error("Canvas context not available"));
          return;
        }

        // Apply background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Filters
        if (img.filter === 'grayscale' || img.filter === 'bw') {
          ctx.filter = 'grayscale(100%)';
        }
        if (img.filter === 'bw') {
          ctx.filter += ' contrast(200%)';
        }

        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((img.rotation * Math.PI) / 180);
        ctx.drawImage(image, -image.width / 2, -image.height / 2);

        // Mock Signature Overlay
        if (img.signature) {
          ctx.rotate(-(img.rotation * Math.PI) / 180); // Reset rotation for signature
          ctx.translate(-canvas.width / 2, -canvas.height / 2); // Reset translation
          
          ctx.font = `bold ${Math.max(20, canvas.width / 10)}px Arial`;
          ctx.fillStyle = 'blue';
          ctx.textAlign = 'right';
          ctx.fillText("Signed via SignFlow", canvas.width - 20, canvas.height - 40);
        }

        resolve({
          dataUrl: canvas.toDataURL('image/jpeg', settings.quality),
          width: canvas.width,
          height: canvas.height
        });
      };
      image.onerror = reject;
      image.crossOrigin = "Anonymous";
      image.src = img.previewUrl;
    });
  };

  for (let i = 0; i < images.length; i++) {
    const processed = await processImage(images[i]);
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    
    // Auto-fit logic
    const imgRatio = processed.width / processed.height;
    const pageRatio = pageWidth / pageHeight;
    
    let finalWidth = pageWidth;
    let finalHeight = pageWidth / imgRatio;

    if (finalHeight > pageHeight) {
      finalHeight = pageHeight;
      finalWidth = pageHeight * imgRatio;
    }

    // Centering
    const x = (pageWidth - finalWidth) / 2;
    const y = (pageHeight - finalHeight) / 2;

    if (i > 0) doc.addPage();
    doc.addImage(processed.dataUrl, 'JPEG', x, y, finalWidth, finalHeight);
    
    // Add invisible text layer for OCR
    if (images[i].extractedText) {
        doc.setFontSize(1);
        doc.setTextColor(255, 255, 255);
        // Clean text
        const safeText = images[i].extractedText!.replace(/[^\x20-\x7E\n]/g, ""); 
        doc.text(safeText.substring(0, 2000), 10, 10, { maxWidth: pageWidth - 20 }); 
    }
  }

  // Create clean filename
  const filenamePrefix = settings.title ? settings.title.replace(/[^a-z0-9]/gi, '_').toLowerCase() : 'document';
  doc.save(`${filenamePrefix}_${new Date().getTime()}.pdf`);
};